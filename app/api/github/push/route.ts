import type { NextRequest } from "next/server"
import { z } from "zod"
import { ApiResponse } from "@/lib/api-response"
import { logger } from "@/lib/logger"
import { validateRequest } from "@/lib/validation"

const githubPushSchema = z.object({
  code: z.string().min(1, "Code is required"),
  repoName: z
    .string()
    .min(1, "Repository name is required")
    .regex(/^[a-zA-Z0-9-_]+$/, "Invalid repository name"),
  description: z.string().optional(),
})

export async function POST(request: NextRequest) {
  try {
    const validation = await validateRequest(request, githubPushSchema)
    if (!validation.success) {
      return ApiResponse.error(validation.error, 400, "VALIDATION_ERROR")
    }

    const { code, repoName, description } = validation.data

    const githubToken = process.env.GITHUB_TOKEN

    if (!githubToken) {
      return ApiResponse.error(
        "GitHub token not configured. Configure GITHUB_TOKEN nas variÃ¡veis de ambiente",
        400,
        "MISSING_TOKEN",
      )
    }

    logger.info("Creating GitHub repository", { repoName })

    const createRepoResponse = await fetch("https://api.github.com/user/repos", {
      method: "POST",
      headers: {
        Authorization: `token ${githubToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name: repoName,
        description: description || "Generated by Wexar AI Website Builder",
        private: false,
        auto_init: true,
      }),
    })

    if (!createRepoResponse.ok) {
      const errorData = await createRepoResponse.json()
      logger.error("Failed to create GitHub repository", { error: errorData, repoName })
      return ApiResponse.error(
        errorData.message || "Failed to create repository",
        createRepoResponse.status,
        "GITHUB_ERROR",
      )
    }

    const repoData = await createRepoResponse.json()
    const owner = repoData.owner.login
    const defaultBranch = repoData.default_branch || "main"

    logger.info("Repository created, pushing code", { repoName, owner })

    await new Promise((resolve) => setTimeout(resolve, 1000))

    // 2. Get the SHA of the latest commit
    const refResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/${defaultBranch}`,
      {
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      },
    )

    if (!refResponse.ok) {
      logger.error("Failed to get repository reference", { repoName })
      return ApiResponse.error("Failed to get repository reference", refResponse.status, "GITHUB_ERROR")
    }

    const refData = await refResponse.json()
    const latestCommitSha = refData.object.sha

    // 3. Create blobs for each file
    const files = [
      { path: "index.html", content: code },
      {
        path: "README.md",
        content: `# ${repoName}\n\n${description || "Generated by Wexar AI Website Builder"}\n\n## Usage\n\nOpen \`index.html\` in your browser to view the website.`,
      },
    ]

    const blobs = await Promise.all(
      files.map(async (file) => {
        const blobResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/blobs`, {
          method: "POST",
          headers: {
            Authorization: `token ${githubToken}`,
            Accept: "application/vnd.github.v3+json",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            content: Buffer.from(file.content).toString("base64"),
            encoding: "base64",
          }),
        })

        if (!blobResponse.ok) {
          throw new Error(`Failed to create blob for ${file.path}`)
        }

        const blobData = await blobResponse.json()
        return {
          path: file.path,
          mode: "100644" as const,
          type: "blob" as const,
          sha: blobData.sha,
        }
      }),
    )

    // 4. Create tree
    const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/trees`, {
      method: "POST",
      headers: {
        Authorization: `token ${githubToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tree: blobs,
      }),
    })

    if (!treeResponse.ok) {
      logger.error("Failed to create tree", { repoName })
      return ApiResponse.error("Failed to create tree", treeResponse.status, "GITHUB_ERROR")
    }

    const treeData = await treeResponse.json()

    // 5. Create commit
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/commits`, {
      method: "POST",
      headers: {
        Authorization: `token ${githubToken}`,
        Accept: "application/vnd.github.v3+json",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        message: "Initial commit - Generated by Wexar AI",
        tree: treeData.sha,
        parents: [latestCommitSha],
      }),
    })

    if (!commitResponse.ok) {
      logger.error("Failed to create commit", { repoName })
      return ApiResponse.error("Failed to create commit", commitResponse.status, "GITHUB_ERROR")
    }

    const commitData = await commitResponse.json()

    // 6. Update reference
    const updateRefResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/${defaultBranch}`,
      {
        method: "PATCH",
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          sha: commitData.sha,
        }),
      },
    )

    if (!updateRefResponse.ok) {
      logger.error("Failed to update reference", { repoName })
      return ApiResponse.error("Failed to update reference", updateRefResponse.status, "GITHUB_ERROR")
    }

    logger.info("Code pushed to GitHub successfully", { repoUrl: repoData.html_url })

    return ApiResponse.success({
      url: repoData.html_url,
      message: "Repository created and code pushed successfully",
    })
  } catch (error) {
    logger.error("GitHub push error", { error })
    return ApiResponse.error(error instanceof Error ? error.message : "Failed to push to GitHub", 500, "INTERNAL_ERROR")
  }
}
